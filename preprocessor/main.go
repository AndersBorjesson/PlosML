package preprocessor

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"ploshml/preprocessor/lexer"
	"ploshml/preprocessor/parser"
	"strings"
)

type LineType struct {
	Text          string
	Filename      string
	Lineno        int
	Indent        int
	NonEmpty      bool
	PossibleOwner bool
	Owner         int
	Used          bool
	IndentID      int
}

type ErrorType struct {
	Err      error
	Filename string
	LineNo   int
}
type Preprocessor struct {
	Filepath   string
	Filename   string
	Textstack  *[]LineType
	Errorstack *[]ErrorType
	tmpstack   []string
}

func (s Preprocessor) ReadFile(filename string) ([]string, error) {
	existance, err := s.check_file_exists(filename)
	valid := existance && (err == nil)
	if valid != true {
		return nil, err
	}
	f, _ := os.Open(filename)
	defer f.Close()

	raw, _ := io.ReadAll(f)
	strslice := strings.Split(string(raw), "\n")
	return strslice, nil
}

func (s Preprocessor) check_file_exists(filename string) (bool, error) {

	_, err := os.Stat(filename)
	if err == nil {
		//fmt.Printf("File %s exists", filename)
		return true, nil
	}
	if errors.Is(err, os.ErrNotExist) {
		fmt.Printf("File %s does not exist", filename)
		return false, err
	}
	return false, err

}

func errorabort(errmess string, err error) {
	if err != nil {
		fmt.Println(errmess)
		os.Exit(2)
	}
}
func (s Preprocessor) Do() {
	filedata, err := s.ReadFile(s.Filename)
	errorabort("File does not exist", err)

	for i, d := range filedata {
		lex := lexer.New([]rune(d))
		// fmt.Println(lex)
		a, _ := parser.New(lex).Parse()
		//fmt.Println("SSS", d, a)
		if a == nil {
			tmp := LineType{Lineno: i,
				Text:     d,
				Filename: s.Filename}
			*s.Textstack = append(*s.Textstack, tmp)
		} else {
			includer := Preprocessor{Filename: a.(string)}
			includer.Textstack = s.Textstack

			includer.Do()
		}

	}
}

func (s Preprocessor) IndentCheck() {
	for i, _ := range *s.Textstack {
		tmp := (*s.Textstack)[i].Text
		no_tabs := 0
		for strings.HasPrefix(tmp, "    ") == true {
			tmp = tmp[4:]
			no_tabs += 1
		}
		(*s.Textstack)[i].Indent = no_tabs
		(*s.Textstack)[i].Text = tmp
		(*s.Textstack)[i].NonEmpty = len(tmp) > 0
		(*s.Textstack)[i].PossibleOwner = false
		(*s.Textstack)[i].Owner = 0
		(*s.Textstack)[i].IndentID = 0
	}

}

func (s Preprocessor) CleanEmpty() {
	var tmp []LineType
	for i, _ := range *s.Textstack {
		if (*s.Textstack)[i].NonEmpty {
			tmp = append(tmp, (*s.Textstack)[i])
		}
	}
	(*s.Textstack) = tmp
}

func (s Preprocessor) Check_ownership() {
	owner := []int{0}
	indentID := []int{0}
	id_now := 0
	for i, _ := range *s.Textstack {
		if (*s.Textstack)[i].NonEmpty {
			if i < (len(*s.Textstack) - 1) {
				if (*s.Textstack)[i].Indent < (*s.Textstack)[i+1].Indent {
					owner = append(owner, owner[len(owner)-1]+1)
					id_now++
					indentID = append(indentID, id_now)
					(*s.Textstack)[i].PossibleOwner = true
					(*s.Textstack)[i+1].Owner = owner[len(owner)-1]
					(*s.Textstack)[i+1].IndentID = indentID[len(owner)-1]

				} else if (*s.Textstack)[i].Indent == (*s.Textstack)[i+1].Indent {
					(*s.Textstack)[i].PossibleOwner = false
					(*s.Textstack)[i+1].Owner = owner[len(owner)-1]
					(*s.Textstack)[i+1].IndentID = indentID[len(indentID)-1]

				} else if (*s.Textstack)[i].Indent > (*s.Textstack)[i+1].Indent {
					delta := (*s.Textstack)[i].Indent - (*s.Textstack)[i+1].Indent

					(*s.Textstack)[i].PossibleOwner = false
					owner = owner[0:(len(owner) - delta)]
					indentID = indentID[0:(len(indentID) - delta)]

					(*s.Textstack)[i+1].Owner = owner[len(owner)-1]
					(*s.Textstack)[i+1].IndentID = indentID[len(owner)-1]
				} else {
					fmt.Println("This should never happen")
					os.Exit(2)
				}
			}
		}
		fmt.Println((*s.Textstack)[i].Text, (*s.Textstack)[i].PossibleOwner, (*s.Textstack)[i].Owner, (*s.Textstack)[i].IndentID)
	}

}
func flagparser() string {

	infile := flag.String("i", "", "Inputfile")
	flag.Parse()
	return *infile
}

// func main() {

// 	infile := flagparser()
// 	// t1Src := "md_test_main.md"
// 	includer := Mdincluder{filename: infile}
// 	includer.textstack = &[]string{}

// 	includer.Do()
// 	fmt.Println("Advice : This file was generated by mdinclude. It is preferred to make changes in the source instead of result")
// 	for _, l := range *includer.textstack {
// 		fmt.Println(l)
// 	}

// 	// lex := lexer.New([]rune(t1Src))
// 	// fmt.Println(lex)
// 	// a, err := parser.New(lex).Parse()
// 	// fmt.Println(a)
// 	// if err != nil {
// 	// 	fmt.Println(err)

// 	// }

// }
